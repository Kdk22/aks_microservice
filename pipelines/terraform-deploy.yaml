trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
- name: 'serviceconnection'
  value: 'AKS-TERRA-AzureRM'

- name: 'environment'
  value: 'dev'

- name: 'backend_rg'
  value: 'store-state-file-rg'

- name: 'backend_storageaccount'
  value: 'backupstatefile'

- name: 'backend_container'
  value: 'stateblob'

- name: 'backendkey_tfstate'
  value: 'terraform.tfstate'

- name: 'working_directory'
  value: '$(System.DefaultWorkingDirectory)'

- name: 'ado_org'
  value: 'https://dev.azure.com/utft0'




stages:
  - stage: KeyVaultAccess
    jobs:
      - job: GetSecrets
        steps:
        - task: AzureKeyVault@2
          inputs:
            azureSubscription: '$(serviceconnection)'
            KeyVaultName: 'aks-proj-kv'
            SecretsFilter: '*'
            RunAsPreJob: true
          displayName: 'Azure Key Vault'

        
        # Verification task
        - task: Bash@3
          inputs:
            targetType: 'inline'
            script: |
              echo "---"
              echo "GitHub-Token: $(github-token)"
              echo "Ado-token: $(ado-token) "
              echo "ssh-public-key: $(ssh-public-key)"

              validate_token() {
                local token_name="$1"
                local token_value="$2"
                local min_length="${3:-1}"  # Default minimum length is 1

                if [ -z "$token_value" ]; then
                  echo "##[error]$token_name is not set!"
                  exit 1
                fi

                token_length=${#token_value}
                echo "Checking $token_name length: $token_length"

                if [ "$token_length" -lt "$min_length" ]; then
                  echo "##[error]$token_name is too short (length: $token_length, minimum: $min_length)!"
                  exit 1
                fi

                echo "##[debug]$token_name is valid (length: $token_length)"
              }

              # Validate each token with a minimum length of 10 characters
              validate_token "GITHUB_TOKEN" "$(github-token)" 10
              validate_token "ADO_TOKEN" "$(ado-token)" 10
              validate_token "SSH_PUBLIC_KEY" "$(ssh-pub-key)" 10

              echo "All tokens validated successfully!"
          displayName: 'Verify Secrets'

  - stage: "runCheckov"
    displayName: "Checkov: Static Code Analysis"
    jobs:
      - job: "runCheckov"
        displayName: "Checkov > Pull, run and publish results of Checkov scan"
        steps:
        - task: Bash@3
          inputs:
            targetType: 'inline'
            script: 'pip install checkov'
            displayName: Install checkov
        - task: Bash@3
          inputs:
            targetType: 'inline'
            workingDirectory: $(working_directory)
            script: 'checkov -d . -o junitxml > scan-result.xml --soft-fail'
            displayName: Checkov source code scan
            continueOnError: true
        - task: PublishTestResults@2
          inputs:
            testResultsFormat: 'JUnit'
            searchFolder: '$(working_directory)'
            testResultsFiles: '**/*scan-result.xml'
            mergeTestResults: false
            testRunTitle: Terraform source code scan
            failTaskOnFailedTests: false
            publishRunAttachments: true
            displayName: Publish Test Result


  # After checkov scans the code i have the terraform validate that checks the syntax error in terraform code
  - stage: validate
    displayName : 'Terraform Validate'
    jobs:
    - job: validate
      continueOnError: false
      steps:
      - task: TerraformInstaller@0
        displayName: 'install'
        inputs:
          terraformVersion: 'latest'
      - task: TerraformTaskV2@2
        displayName: 'init'
        inputs:
          provider: 'azurerm'
          command: 'init'
          backendServiceArm: $(serviceconnection)
          backendAzureRmResourceGroupName: '$(backend_rg)'
          backendAzureRmStorageAccountName: $(backend_storageaccount)
          backendAzureRmContainerName: $(backend_container)
          backendAzureRmKey: $(backendkey_tfstate)
          workingDirectory: '$(working_directory)'
      - task: TerraformTaskV2@2
        displayName: 'validate'
        inputs:
          provider: 'azurerm'
          command: 'validate' 

  # if the validate succeds we plan and apply 
  # and in plan stage i have set multiple checkpoints becuase i have set apply to auto approve 
  
  - stage: Plan_Apply_dev
    dependsOn: [validate]
    condition: succeeded('validate')
    displayName: Plan_Apply_dev
    jobs:
      - deployment: 'Approval_Apply_Stage'
        displayName: 'Approval gate for this stage'
        environment: 'dev'
        strategy:
          runOnce:
            deploy:
              steps:
              - checkout: self
      - job: plan
        displayName: 'Terraform_plan_dev'
        continueOnError: false
        steps:
        - task: TerraformInstaller@0
          displayName: 'install'
          inputs:
            terraformVersion: 'latest'
        - task: TerraformTaskV2@2
          displayName: init
          inputs:
            provider: 'azurerm'
            command: 'init'
            backendServiceArm: $(serviceconnection)
            backendAzureRmResourceGroupName: '$(backend_rg)'
            backendAzureRmStorageAccountName: $(backend_storageaccount)
            backendAzureRmContainerName: $(backend_container)
            backendAzureRmKey: $(backendkey_tfstate)
            workingDirectory: '$(working_directory)'
        - task: TerraformTaskV2@2
          displayName: plan
          inputs:
            provider: 'azurerm'
            command: 'plan'
            commandOptions: '-input=false -var-file="terraform.tfvars" -var="github_token=$(github-token)" -var="ado_token=$(ado-token)" -var="ssh_public_key=$(ssh-pub-key)"'
            environmentServiceNameAzureRM: $(serviceconnection)
            workingDirectory: '$(working_directory)'

  #Checkov to scan the execution plan for vulnerabilities and exposed outputs
        - task: Bash@3
          inputs:
            targetType: 'inline'
            script: 'pip install checkov'
            displayName: Install checkov        
        - task: Bash@3
          inputs:
            targetType: 'inline'
            workingDirectory: '$(working_directory)'           
            script: |
                    terraform show -json main.tfplan > main.json
                      checkov --skip-check "CKV_AZURE_101,CKV_AZURE_140,CKV_AZURE_100,CKV_AZURE_99,CKV_AZURE_107,CKV2_AZURE_18,CKV2_AZURE_1,CKV_AZURE_110,CKV_AZURE_42,CKV_AZURE_41,CKV_AZURE_109" -f main.json -o junitxml > Checkov-Plan-Report.xml --soft-fail
          continueOnError: true
          displayName: Checkov plan scan
        - task: PublishTestResults@2
          inputs:
            testResultsFormat: 'JUnit'
            searchFolder: '$(working_directory)'
            testResultsFiles: '**/*Checkov-Plan-Report.xml'
            mergeTestResults: false
            testRunTitle: Checkov $(environment) workspace plan scan
            failTaskOnFailedTests: false
            publishRunAttachments: true
          displayName: Publish Test Result
      - job: waitForValidation
        displayName: Wait for execution plan validation
        pool: server
        timeoutInMinutes: 4320 # job times out in 3 days
        steps:
        - task: ManualValidation@0
          timeoutInMinutes: 1440 # task times out in 1 day
          inputs:
            notifyUsers: |
              khadkautshav7@gmail.com
            instructions: 'Please validate the build configuration and resume'
            onTimeout: 'reject'
      
  # Adding the apply job
  #timeoutInMinutes: 0 is very important else the pipeline job will timeout

      - job: Terraform_apply_dev
        dependsOn :
        - plan
        - waitForValidation
        condition: |
          and
          (
            eq(dependencies.plan.result, 'Succeeded'),
            eq(dependencies.waitForValidation.result, 'Succeeded')
          )
        timeoutInMinutes: 0
        steps:
        - checkout: self
        - task: TerraformInstaller@0
          displayName: 'install'
          inputs:
            terraformVersion: 'latest'
        - task: TerraformTaskV2@2
          displayName: 'init'
          inputs:
            provider: 'azurerm'
            command: 'init'
            backendServiceArm: $(serviceconnection)
            backendAzureRmResourceGroupName: '$(backend_rg)'
            backendAzureRmStorageAccountName: $(backend_storageaccount)
            backendAzureRmContainerName: $(backend_container)
            backendAzureRmKey: $(backendkey_tfstate)
            workingDirectory: '$(working_directory)'
        - bash: |
            export AZDO_PERSONAL_ACCESS_TOKEN: $(ado-token)
            export AZDO_ORG_SERVICE_URL: $(ado_org)
            export AZDO_GITHUB_SERVICE_CONNECTION_PAT: $(github-token)

        - task: Bash@3
          inputs:
            targetType: 'inline'
            script: 'printenv'
            displayName: printenv
            
        - task: TerraformTaskV2@2
          displayName: 'plan'
          inputs:
            provider: 'azurerm'
            command: 'plan'
            commandOptions: '-input=false -var-file="terraform.tfvars" -var="github_token=$(github-token)" -var="ado_token=$(ado-token)" -var="ssh_public_key=$(ssh-pub-key)"'
            environmentServiceNameAzureRM: $(serviceconnection)
            workingDirectory: '$(working_directory)'

        - task: TerraformTaskV2@2
          displayName: 'apply'
          inputs:
            provider: 'azurerm'
            command: 'apply'
            commandOptions: '-input=false -auto-approve -var-file="terraform.tfvars" -var="github_token=$(github-token)" -var="ado_token=$(ado-token)" -var="ssh_public_key=$(ssh-pub-key)"'
            environmentServiceNameAzureRM: $(serviceconnection)
            workingDirectory: '$(working_directory)'
